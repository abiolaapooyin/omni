"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/research";
exports.ids = ["pages/api/research"];
exports.modules = {

/***/ "(api)/./pages/api/research.js":
/*!*******************************!*\
  !*** ./pages/api/research.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _utils_contentFilter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/contentFilter */ \"(api)/./utils/contentFilter.js\");\n// Next.js API route to proxy research requests and bypass CORS\n\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    const { query  } = req.body;\n    if (!query) {\n        return res.status(400).json({\n            error: \"Query is required\"\n        });\n    }\n    try {\n        console.log(\"Proxying research request for:\", query);\n        // First API call to initiate research\n        const response = await fetch(\"https://agents-mcp-hackathon-researchcopilot.hf.space/gradio_api/call/conduct_research_sync\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"User-Agent\": \"Research-Proxy/1.0\"\n            },\n            body: JSON.stringify({\n                data: [\n                    query\n                ]\n            })\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"API Error:\", response.status, errorText);\n            return res.status(response.status).json({\n                error: `API Error: ${errorText}`\n            });\n        }\n        const data = await response.json();\n        console.log(\"Initial response:\", data);\n        const eventId = data.event_id;\n        if (!eventId) {\n            console.error(\"No event ID received:\", data);\n            return res.status(500).json({\n                error: \"No event ID received from research API\"\n            });\n        }\n        // Wait a moment before polling\n        await new Promise((resolve)=>setTimeout(resolve, 2000));\n        // Second API call to get results\n        const resultsUrl = `https://agents-mcp-hackathon-researchcopilot.hf.space/gradio_api/call/conduct_research_sync/${eventId}`;\n        console.log(\"Fetching results from:\", resultsUrl);\n        const resultsResponse = await fetch(resultsUrl, {\n            headers: {\n                \"User-Agent\": \"Research-Proxy/1.0\"\n            }\n        });\n        if (!resultsResponse.ok) {\n            const errorText1 = await resultsResponse.text();\n            console.error(\"Results API Error:\", resultsResponse.status, errorText1);\n            return res.status(resultsResponse.status).json({\n                error: `Results API Error: ${errorText1}`\n            });\n        }\n        // Process the streaming response\n        const reader = resultsResponse.body.getReader();\n        const decoder = new TextDecoder();\n        let result = \"\";\n        let buffer = \"\";\n        while(true){\n            const { done , value  } = await reader.read();\n            if (done) break;\n            const chunk = decoder.decode(value);\n            result += chunk;\n            buffer += chunk;\n            // Process complete lines from buffer\n            const lines = buffer.split(\"\\n\");\n            // Keep the last incomplete line in buffer\n            buffer = lines.pop() || \"\";\n            for (const line of lines){\n                if (line.startsWith(\"data: \")) {\n                    const dataContent = line.slice(6);\n                    // Skip null data\n                    if (dataContent.trim() === \"null\") {\n                        continue;\n                    }\n                    try {\n                        const jsonData = JSON.parse(dataContent);\n                        if (jsonData && Array.isArray(jsonData) && jsonData.length >= 4) {\n                            console.log(\"Research completed successfully\");\n                            console.log(\"Raw sources data:\", jsonData[1]);\n                            console.log(\"Raw citations data:\", jsonData[2]);\n                            // Helper function to ensure array format\n                            const ensureArray = (data)=>{\n                                // Helper to check if a string is a valid source (not a header or metadata)\n                                const isValidSource = (str)=>{\n                                    if (!str || typeof str !== \"string\") return false;\n                                    const trimmed = str.trim();\n                                    // Filter out headers, empty lines, and metadata\n                                    if (trimmed.startsWith(\"#\") || trimmed.startsWith(\"Sources Found\") || trimmed.length < 10 || trimmed === \"# Sources Found\" || /^\\d+\\.$/.test(trimmed)) {\n                                        return false;\n                                    }\n                                    return true;\n                                };\n                                if (Array.isArray(data)) {\n                                    // If it's already an array, check if items need parsing\n                                    return data.filter((item)=>{\n                                        if (typeof item === \"string\") {\n                                            return isValidSource(item);\n                                        }\n                                        return item && typeof item === \"object\";\n                                    }).map((item, index)=>{\n                                        if (typeof item === \"string\") {\n                                            // Parse string items into source objects\n                                            const urlMatch = item.match(/(https?:\\/\\/[^\\s]+)/);\n                                            const url = urlMatch ? urlMatch[1] : null;\n                                            const title = item.replace(/(https?:\\/\\/[^\\s]+)/, \"\").trim() || `Source ${index + 1}`;\n                                            return {\n                                                title: title || `Source ${index + 1}`,\n                                                url: url,\n                                                type: \"web\",\n                                                description: item\n                                            };\n                                        }\n                                        return item;\n                                    });\n                                }\n                                if (typeof data === \"string\") {\n                                    try {\n                                        const parsed = JSON.parse(data);\n                                        return Array.isArray(parsed) ? ensureArray(parsed) : [\n                                            data\n                                        ];\n                                    } catch  {\n                                        // Try to parse as structured source data\n                                        const lines = data.split(\"\\n\").filter((line)=>line.trim() && isValidSource(line));\n                                        return lines.map((line, index)=>{\n                                            const urlMatch = line.match(/(https?:\\/\\/[^\\s]+)/);\n                                            const url = urlMatch ? urlMatch[1] : null;\n                                            const title = line.replace(/(https?:\\/\\/[^\\s]+)/, \"\").trim() || `Source ${index + 1}`;\n                                            return {\n                                                title: title || `Source ${index + 1}`,\n                                                url: url,\n                                                type: \"web\",\n                                                description: line\n                                            };\n                                        });\n                                    }\n                                }\n                                return data ? [\n                                    data\n                                ] : [];\n                            };\n                            const researchData = {\n                                summary: jsonData[0] || \"Research completed successfully.\",\n                                sources: ensureArray(jsonData[1]),\n                                citations: ensureArray(jsonData[2]),\n                                processLog: ensureArray(jsonData[3])\n                            };\n                            // Filter content to replace 'perplexity' with 'omni'\n                            const filteredData = (0,_utils_contentFilter__WEBPACK_IMPORTED_MODULE_0__.filterResearchResults)(researchData);\n                            return res.status(200).json({\n                                success: true,\n                                data: filteredData\n                            });\n                        }\n                    } catch (e) {\n                        // For multi-line JSON, try to accumulate until we have complete JSON\n                        console.log(\"Failed to parse data line (might be incomplete):\", dataContent.substring(0, 100));\n                    }\n                }\n            }\n        }\n        // Process any remaining data in buffer\n        if (buffer.startsWith(\"data: \")) {\n            const dataContent1 = buffer.slice(6);\n            try {\n                const jsonData1 = JSON.parse(dataContent1);\n                if (jsonData1 && Array.isArray(jsonData1) && jsonData1.length >= 4) {\n                    console.log(\"Research completed successfully (from buffer)\");\n                    // Helper function to ensure array format\n                    const ensureArray1 = (data)=>{\n                        // Helper to check if a string is a valid source (not a header or metadata)\n                        const isValidSource = (str)=>{\n                            if (!str || typeof str !== \"string\") return false;\n                            const trimmed = str.trim();\n                            // Filter out headers, empty lines, and metadata\n                            if (trimmed.startsWith(\"#\") || trimmed.startsWith(\"Sources Found\") || trimmed.length < 10 || trimmed === \"# Sources Found\" || /^\\d+\\.$/.test(trimmed)) {\n                                return false;\n                            }\n                            return true;\n                        };\n                        if (Array.isArray(data)) {\n                            // If it's already an array, check if items need parsing\n                            return data.filter((item)=>{\n                                if (typeof item === \"string\") {\n                                    return isValidSource(item);\n                                }\n                                return item && typeof item === \"object\";\n                            }).map((item, index)=>{\n                                if (typeof item === \"string\") {\n                                    // Parse string items into source objects\n                                    const urlMatch = item.match(/(https?:\\/\\/[^\\s]+)/);\n                                    const url = urlMatch ? urlMatch[1] : null;\n                                    const title = item.replace(/(https?:\\/\\/[^\\s]+)/, \"\").trim() || `Source ${index + 1}`;\n                                    return {\n                                        title: title || `Source ${index + 1}`,\n                                        url: url,\n                                        type: \"web\",\n                                        description: item\n                                    };\n                                }\n                                return item;\n                            });\n                        }\n                        if (typeof data === \"string\") {\n                            try {\n                                const parsed = JSON.parse(data);\n                                return Array.isArray(parsed) ? ensureArray1(parsed) : [\n                                    data\n                                ];\n                            } catch  {\n                                // Try to parse as structured source data\n                                const lines = data.split(\"\\n\").filter((line)=>line.trim() && isValidSource(line));\n                                return lines.map((line, index)=>{\n                                    const urlMatch = line.match(/(https?:\\/\\/[^\\s]+)/);\n                                    const url = urlMatch ? urlMatch[1] : null;\n                                    const title = line.replace(/(https?:\\/\\/[^\\s]+)/, \"\").trim() || `Source ${index + 1}`;\n                                    return {\n                                        title: title || `Source ${index + 1}`,\n                                        url: url,\n                                        type: \"web\",\n                                        description: line\n                                    };\n                                });\n                            }\n                        }\n                        return data ? [\n                            data\n                        ] : [];\n                    };\n                    const researchData1 = {\n                        summary: jsonData1[0] || \"Research completed successfully.\",\n                        sources: ensureArray1(jsonData1[1]),\n                        citations: ensureArray1(jsonData1[2]),\n                        processLog: ensureArray1(jsonData1[3])\n                    };\n                    // Filter content to replace 'perplexity' with 'omni'\n                    const filteredData1 = (0,_utils_contentFilter__WEBPACK_IMPORTED_MODULE_0__.filterResearchResults)(researchData1);\n                    return res.status(200).json({\n                        success: true,\n                        data: filteredData1\n                    });\n                }\n            } catch (e1) {\n                console.log(\"Failed to parse final buffer data\");\n            }\n        }\n        // Try to extract data from the complete result as fallback\n        const dataMatch = result.match(/data: (\\[.*\\])/s);\n        if (dataMatch) {\n            try {\n                const jsonData2 = JSON.parse(dataMatch[1]);\n                if (jsonData2 && Array.isArray(jsonData2) && jsonData2.length >= 4) {\n                    console.log(\"Research completed successfully (from regex match)\");\n                    // Helper function to ensure array format\n                    const ensureArray2 = (data)=>{\n                        // Helper to check if a string is a valid source (not a header or metadata)\n                        const isValidSource = (str)=>{\n                            if (!str || typeof str !== \"string\") return false;\n                            const trimmed = str.trim();\n                            // Filter out headers, empty lines, and metadata\n                            if (trimmed.startsWith(\"#\") || trimmed.startsWith(\"Sources Found\") || trimmed.length < 10 || trimmed === \"# Sources Found\" || /^\\d+\\.$/.test(trimmed)) {\n                                return false;\n                            }\n                            return true;\n                        };\n                        if (Array.isArray(data)) {\n                            return data.filter((item)=>{\n                                if (typeof item === \"string\") {\n                                    return isValidSource(item);\n                                }\n                                return item && typeof item === \"object\";\n                            }).map((item, index)=>{\n                                if (typeof item === \"string\") {\n                                    // Parse string items into source objects\n                                    const urlMatch = item.match(/(https?:\\/\\/[^\\s]+)/);\n                                    const url = urlMatch ? urlMatch[1] : null;\n                                    const title = item.replace(/(https?:\\/\\/[^\\s]+)/, \"\").trim() || `Source ${index + 1}`;\n                                    return {\n                                        title: title || `Source ${index + 1}`,\n                                        url: url,\n                                        type: \"web\",\n                                        description: item\n                                    };\n                                }\n                                return item;\n                            });\n                        }\n                        if (typeof data === \"string\") {\n                            try {\n                                const parsed = JSON.parse(data);\n                                return Array.isArray(parsed) ? ensureArray2(parsed) : [\n                                    data\n                                ];\n                            } catch  {\n                                // Try to parse as structured source data\n                                const lines = data.split(\"\\n\").filter((line)=>line.trim() && isValidSource(line));\n                                return lines.map((line, index)=>{\n                                    const urlMatch = line.match(/(https?:\\/\\/[^\\s]+)/);\n                                    const url = urlMatch ? urlMatch[1] : null;\n                                    const title = line.replace(/(https?:\\/\\/[^\\s]+)/, \"\").trim() || `Source ${index + 1}`;\n                                    return {\n                                        title: title || `Source ${index + 1}`,\n                                        url: url,\n                                        type: \"web\",\n                                        description: line\n                                    };\n                                });\n                            }\n                        }\n                        return data ? [\n                            data\n                        ] : [];\n                    };\n                    const researchData2 = {\n                        summary: jsonData2[0] || \"Research completed successfully.\",\n                        sources: ensureArray2(jsonData2[1]),\n                        citations: ensureArray2(jsonData2[2]),\n                        processLog: ensureArray2(jsonData2[3])\n                    };\n                    // Filter content to replace 'perplexity' with 'omni'\n                    const filteredData2 = (0,_utils_contentFilter__WEBPACK_IMPORTED_MODULE_0__.filterResearchResults)(researchData2);\n                    return res.status(200).json({\n                        success: true,\n                        data: filteredData2\n                    });\n                }\n            } catch (e2) {\n                console.log(\"Failed to parse regex matched data\");\n            }\n        }\n        // If we get here, no valid data was found\n        console.error(\"No valid research data found in response\");\n        return res.status(500).json({\n            error: \"No research data received from API\",\n            debug: result.substring(0, 500) // First 500 chars for debugging\n        });\n    } catch (error) {\n        console.error(\"Proxy error:\", error);\n        return res.status(500).json({\n            error: \"Internal server error: \" + error.message\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsQ0FBQyxDQUFDO3FCQUNyQztvQkFFRCxxREFBcUQ7b0JBQ3JELE1BQU0yQixhQUFZLEdBQUcxRSwyRUFBcUIsQ0FBQ3FFLGFBQVksQ0FBQztvQkFFeEQsT0FBT2xFLEdBQUcsQ0FBQ0UsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDQyxJQUFJLENBQUM7d0JBQzFCcUUsT0FBTyxFQUFFLElBQUk7d0JBQ2IxRCxJQUFJLEVBQUV5RCxhQUFZO3FCQUNuQixDQUFDO2dCQUNKLENBQUM7WUFDSCxFQUFFLE9BQU9FLEVBQUMsRUFBRTtnQkFDVmxFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLG9DQUFvQyxDQUFDO1lBQ25ELENBQUM7UUFDSCxDQUFDO1FBRUQsMENBQTBDO1FBQzFDRCxPQUFPLENBQUNILEtBQUssQ0FBQywwQ0FBMEMsQ0FBQztRQUN6RCxPQUFPSixHQUFHLENBQUNFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQ0MsSUFBSSxDQUFDO1lBQzFCQyxLQUFLLEVBQUUsb0NBQW9DO1lBQzNDd0UsS0FBSyxFQUFFL0MsTUFBTSxDQUFDNkMsU0FBUyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxnQ0FBZ0M7U0FDakUsQ0FBQztJQUVKLEVBQUUsT0FBT3RFLEtBQUssRUFBRTtRQUNkRyxPQUFPLENBQUNILEtBQUssQ0FBQyxjQUFjLEVBQUVBLEtBQUssQ0FBQztRQUNwQyxPQUFPSixHQUFHLENBQUNFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQ0MsSUFBSSxDQUFDO1lBQzFCQyxLQUFLLEVBQUUseUJBQXlCLEdBQUdBLEtBQUssQ0FBQ3lFLE9BQU87U0FDakQsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb21uaS1haS1pbnRlcmZhY2UvLi9wYWdlcy9hcGkvcmVzZWFyY2guanM/YjZlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOZXh0LmpzIEFQSSByb3V0ZSB0byBwcm94eSByZXNlYXJjaCByZXF1ZXN0cyBhbmQgYnlwYXNzIENPUlNcbmltcG9ydCB7IGZpbHRlclJlc2VhcmNoUmVzdWx0cyB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbnRlbnRGaWx0ZXInXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMpIHtcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IGVycm9yOiAnTWV0aG9kIG5vdCBhbGxvd2VkJyB9KVxuICB9XG5cbiAgY29uc3QgeyBxdWVyeSB9ID0gcmVxLmJvZHlcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdRdWVyeSBpcyByZXF1aXJlZCcgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1Byb3h5aW5nIHJlc2VhcmNoIHJlcXVlc3QgZm9yOicsIHF1ZXJ5KVxuXG4gICAgLy8gRmlyc3QgQVBJIGNhbGwgdG8gaW5pdGlhdGUgcmVzZWFyY2hcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL2FnZW50cy1tY3AtaGFja2F0aG9uLXJlc2VhcmNoY29waWxvdC5oZi5zcGFjZS9ncmFkaW9fYXBpL2NhbGwvY29uZHVjdF9yZXNlYXJjaF9zeW5jJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdVc2VyLUFnZW50JzogJ1Jlc2VhcmNoLVByb3h5LzEuMCdcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRhdGE6IFtxdWVyeV1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgICAgY29uc29sZS5lcnJvcignQVBJIEVycm9yOicsIHJlc3BvbnNlLnN0YXR1cywgZXJyb3JUZXh0KVxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMocmVzcG9uc2Uuc3RhdHVzKS5qc29uKHsgXG4gICAgICAgIGVycm9yOiBgQVBJIEVycm9yOiAke2Vycm9yVGV4dH1gIFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgY29uc29sZS5sb2coJ0luaXRpYWwgcmVzcG9uc2U6JywgZGF0YSlcblxuICAgIGNvbnN0IGV2ZW50SWQgPSBkYXRhLmV2ZW50X2lkXG5cbiAgICBpZiAoIWV2ZW50SWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGV2ZW50IElEIHJlY2VpdmVkOicsIGRhdGEpXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBcbiAgICAgICAgZXJyb3I6ICdObyBldmVudCBJRCByZWNlaXZlZCBmcm9tIHJlc2VhcmNoIEFQSScgXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFdhaXQgYSBtb21lbnQgYmVmb3JlIHBvbGxpbmdcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpXG5cbiAgICAvLyBTZWNvbmQgQVBJIGNhbGwgdG8gZ2V0IHJlc3VsdHNcbiAgICBjb25zdCByZXN1bHRzVXJsID0gYGh0dHBzOi8vYWdlbnRzLW1jcC1oYWNrYXRob24tcmVzZWFyY2hjb3BpbG90LmhmLnNwYWNlL2dyYWRpb19hcGkvY2FsbC9jb25kdWN0X3Jlc2VhcmNoX3N5bmMvJHtldmVudElkfWBcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgcmVzdWx0cyBmcm9tOicsIHJlc3VsdHNVcmwpXG5cbiAgICBjb25zdCByZXN1bHRzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXN1bHRzVXJsLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdVc2VyLUFnZW50JzogJ1Jlc2VhcmNoLVByb3h5LzEuMCdcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKCFyZXN1bHRzUmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3VsdHNSZXNwb25zZS50ZXh0KClcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Jlc3VsdHMgQVBJIEVycm9yOicsIHJlc3VsdHNSZXNwb25zZS5zdGF0dXMsIGVycm9yVGV4dClcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKHJlc3VsdHNSZXNwb25zZS5zdGF0dXMpLmpzb24oeyBcbiAgICAgICAgZXJyb3I6IGBSZXN1bHRzIEFQSSBFcnJvcjogJHtlcnJvclRleHR9YCBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyB0aGUgc3RyZWFtaW5nIHJlc3BvbnNlXG4gICAgY29uc3QgcmVhZGVyID0gcmVzdWx0c1Jlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICBsZXQgcmVzdWx0ID0gJydcbiAgICBsZXQgYnVmZmVyID0gJydcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgICBpZiAoZG9uZSkgYnJlYWtcblxuICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSlcbiAgICAgIHJlc3VsdCArPSBjaHVua1xuICAgICAgYnVmZmVyICs9IGNodW5rXG5cbiAgICAgIC8vIFByb2Nlc3MgY29tcGxldGUgbGluZXMgZnJvbSBidWZmZXJcbiAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKVxuICAgICAgLy8gS2VlcCB0aGUgbGFzdCBpbmNvbXBsZXRlIGxpbmUgaW4gYnVmZmVyXG4gICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJ1xuXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcbiAgICAgICAgICBjb25zdCBkYXRhQ29udGVudCA9IGxpbmUuc2xpY2UoNilcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTa2lwIG51bGwgZGF0YVxuICAgICAgICAgIGlmIChkYXRhQ29udGVudC50cmltKCkgPT09ICdudWxsJykge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25EYXRhID0gSlNPTi5wYXJzZShkYXRhQ29udGVudClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGpzb25EYXRhICYmIEFycmF5LmlzQXJyYXkoanNvbkRhdGEpICYmIGpzb25EYXRhLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXNlYXJjaCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JhdyBzb3VyY2VzIGRhdGE6JywganNvbkRhdGFbMV0pXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSYXcgY2l0YXRpb25zIGRhdGE6JywganNvbkRhdGFbMl0pXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZW5zdXJlIGFycmF5IGZvcm1hdFxuICAgICAgICAgICAgICBjb25zdCBlbnN1cmVBcnJheSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSGVscGVyIHRvIGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgc291cmNlIChub3QgYSBoZWFkZXIgb3IgbWV0YWRhdGEpXG4gICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNvdXJjZSA9IChzdHIpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICghc3RyIHx8IHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzdHIudHJpbSgpXG4gICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGhlYWRlcnMsIGVtcHR5IGxpbmVzLCBhbmQgbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJyMnKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkLnN0YXJ0c1dpdGgoJ1NvdXJjZXMgRm91bmQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIHRyaW1tZWQubGVuZ3RoIDwgMTAgfHxcbiAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkID09PSAnIyBTb3VyY2VzIEZvdW5kJyB8fFxuICAgICAgICAgICAgICAgICAgICAgIC9eXFxkK1xcLiQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGFuIGFycmF5LCBjaGVjayBpZiBpdGVtcyBuZWVkIHBhcnNpbmdcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkU291cmNlKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICB9KS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBzdHJpbmcgaXRlbXMgaW50byBzb3VyY2Ugb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybE1hdGNoID0gaXRlbS5tYXRjaCgvKGh0dHBzPzpcXC9cXC9bXlxcc10rKS8pXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gdXJsTWF0Y2ggPyB1cmxNYXRjaFsxXSA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aXRsZSA9IGl0ZW0ucmVwbGFjZSgvKGh0dHBzPzpcXC9cXC9bXlxcc10rKS8sICcnKS50cmltKCkgfHwgYFNvdXJjZSAke2luZGV4ICsgMX1gXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSB8fCBgU291cmNlICR7aW5kZXggKyAxfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3ZWInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGFyc2VkKSA/IGVuc3VyZUFycmF5KHBhcnNlZCkgOiBbZGF0YV1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgc3RydWN0dXJlZCBzb3VyY2UgZGF0YVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGRhdGEuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICYmIGlzVmFsaWRTb3VyY2UobGluZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcy5tYXAoKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsTWF0Y2ggPSBsaW5lLm1hdGNoKC8oaHR0cHM/OlxcL1xcL1teXFxzXSspLylcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxNYXRjaCA/IHVybE1hdGNoWzFdIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gbGluZS5yZXBsYWNlKC8oaHR0cHM/OlxcL1xcL1teXFxzXSspLywgJycpLnRyaW0oKSB8fCBgU291cmNlICR7aW5kZXggKyAxfWBcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlIHx8IGBTb3VyY2UgJHtpbmRleCArIDF9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dlYicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbGluZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBbZGF0YV0gOiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCByZXNlYXJjaERhdGEgPSB7XG4gICAgICAgICAgICAgICAgc3VtbWFyeToganNvbkRhdGFbMF0gfHwgJ1Jlc2VhcmNoIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VzOiBlbnN1cmVBcnJheShqc29uRGF0YVsxXSksXG4gICAgICAgICAgICAgICAgY2l0YXRpb25zOiBlbnN1cmVBcnJheShqc29uRGF0YVsyXSksXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0xvZzogZW5zdXJlQXJyYXkoanNvbkRhdGFbM10pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEZpbHRlciBjb250ZW50IHRvIHJlcGxhY2UgJ3BlcnBsZXhpdHknIHdpdGggJ29tbmknXG4gICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IGZpbHRlclJlc2VhcmNoUmVzdWx0cyhyZXNlYXJjaERhdGEpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogZmlsdGVyZWREYXRhXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gRm9yIG11bHRpLWxpbmUgSlNPTiwgdHJ5IHRvIGFjY3VtdWxhdGUgdW50aWwgd2UgaGF2ZSBjb21wbGV0ZSBKU09OXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIHBhcnNlIGRhdGEgbGluZSAobWlnaHQgYmUgaW5jb21wbGV0ZSk6JywgZGF0YUNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbnkgcmVtYWluaW5nIGRhdGEgaW4gYnVmZmVyXG4gICAgaWYgKGJ1ZmZlci5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xuICAgICAgY29uc3QgZGF0YUNvbnRlbnQgPSBidWZmZXIuc2xpY2UoNilcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpzb25EYXRhID0gSlNPTi5wYXJzZShkYXRhQ29udGVudClcbiAgICAgICAgaWYgKGpzb25EYXRhICYmIEFycmF5LmlzQXJyYXkoanNvbkRhdGEpICYmIGpzb25EYXRhLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1Jlc2VhcmNoIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgKGZyb20gYnVmZmVyKScpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGVuc3VyZSBhcnJheSBmb3JtYXRcbiAgICAgICAgICBjb25zdCBlbnN1cmVBcnJheSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBIZWxwZXIgdG8gY2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBzb3VyY2UgKG5vdCBhIGhlYWRlciBvciBtZXRhZGF0YSlcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRTb3VyY2UgPSAoc3RyKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghc3RyIHx8IHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHN0ci50cmltKClcbiAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBoZWFkZXJzLCBlbXB0eSBsaW5lcywgYW5kIG1ldGFkYXRhXG4gICAgICAgICAgICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJyMnKSB8fCBcbiAgICAgICAgICAgICAgICAgIHRyaW1tZWQuc3RhcnRzV2l0aCgnU291cmNlcyBGb3VuZCcpIHx8XG4gICAgICAgICAgICAgICAgICB0cmltbWVkLmxlbmd0aCA8IDEwIHx8XG4gICAgICAgICAgICAgICAgICB0cmltbWVkID09PSAnIyBTb3VyY2VzIEZvdW5kJyB8fFxuICAgICAgICAgICAgICAgICAgL15cXGQrXFwuJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBhbiBhcnJheSwgY2hlY2sgaWYgaXRlbXMgbmVlZCBwYXJzaW5nXG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZFNvdXJjZShpdGVtKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgfSkubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHN0cmluZyBpdGVtcyBpbnRvIHNvdXJjZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgICBjb25zdCB1cmxNYXRjaCA9IGl0ZW0ubWF0Y2goLyhodHRwcz86XFwvXFwvW15cXHNdKykvKVxuICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gdXJsTWF0Y2ggPyB1cmxNYXRjaFsxXSA6IG51bGxcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gaXRlbS5yZXBsYWNlKC8oaHR0cHM/OlxcL1xcL1teXFxzXSspLywgJycpLnRyaW0oKSB8fCBgU291cmNlICR7aW5kZXggKyAxfWBcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSB8fCBgU291cmNlICR7aW5kZXggKyAxfWAsXG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd2ViJyxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGl0ZW1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGFyc2VkKSA/IGVuc3VyZUFycmF5KHBhcnNlZCkgOiBbZGF0YV1cbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFzIHN0cnVjdHVyZWQgc291cmNlIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGRhdGEuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICYmIGlzVmFsaWRTb3VyY2UobGluZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzLm1hcCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVybE1hdGNoID0gbGluZS5tYXRjaCgvKGh0dHBzPzpcXC9cXC9bXlxcc10rKS8pXG4gICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxNYXRjaCA/IHVybE1hdGNoWzFdIDogbnVsbFxuICAgICAgICAgICAgICAgICAgY29uc3QgdGl0bGUgPSBsaW5lLnJlcGxhY2UoLyhodHRwcz86XFwvXFwvW15cXHNdKykvLCAnJykudHJpbSgpIHx8IGBTb3VyY2UgJHtpbmRleCArIDF9YFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlIHx8IGBTb3VyY2UgJHtpbmRleCArIDF9YCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3ZWInLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbGluZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhID8gW2RhdGFdIDogW11cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcmVzZWFyY2hEYXRhID0ge1xuICAgICAgICAgICAgc3VtbWFyeToganNvbkRhdGFbMF0gfHwgJ1Jlc2VhcmNoIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuJyxcbiAgICAgICAgICAgIHNvdXJjZXM6IGVuc3VyZUFycmF5KGpzb25EYXRhWzFdKSxcbiAgICAgICAgICAgIGNpdGF0aW9uczogZW5zdXJlQXJyYXkoanNvbkRhdGFbMl0pLFxuICAgICAgICAgICAgcHJvY2Vzc0xvZzogZW5zdXJlQXJyYXkoanNvbkRhdGFbM10pXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpbHRlciBjb250ZW50IHRvIHJlcGxhY2UgJ3BlcnBsZXhpdHknIHdpdGggJ29tbmknXG4gICAgICAgICAgY29uc3QgZmlsdGVyZWREYXRhID0gZmlsdGVyUmVzZWFyY2hSZXN1bHRzKHJlc2VhcmNoRGF0YSlcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkRGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBwYXJzZSBmaW5hbCBidWZmZXIgZGF0YScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjb21wbGV0ZSByZXN1bHQgYXMgZmFsbGJhY2tcbiAgICBjb25zdCBkYXRhTWF0Y2ggPSByZXN1bHQubWF0Y2goL2RhdGE6IChcXFsuKlxcXSkvcylcbiAgICBpZiAoZGF0YU1hdGNoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqc29uRGF0YSA9IEpTT04ucGFyc2UoZGF0YU1hdGNoWzFdKVxuICAgICAgICBpZiAoanNvbkRhdGEgJiYgQXJyYXkuaXNBcnJheShqc29uRGF0YSkgJiYganNvbkRhdGEubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVzZWFyY2ggY29tcGxldGVkIHN1Y2Nlc3NmdWxseSAoZnJvbSByZWdleCBtYXRjaCknKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBlbnN1cmUgYXJyYXkgZm9ybWF0XG4gICAgICAgICAgY29uc3QgZW5zdXJlQXJyYXkgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gSGVscGVyIHRvIGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgc291cmNlIChub3QgYSBoZWFkZXIgb3IgbWV0YWRhdGEpXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkU291cmNlID0gKHN0cikgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXN0ciB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBzdHIudHJpbSgpXG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgaGVhZGVycywgZW1wdHkgbGluZXMsIGFuZCBtZXRhZGF0YVxuICAgICAgICAgICAgICBpZiAodHJpbW1lZC5zdGFydHNXaXRoKCcjJykgfHwgXG4gICAgICAgICAgICAgICAgICB0cmltbWVkLnN0YXJ0c1dpdGgoJ1NvdXJjZXMgRm91bmQnKSB8fFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZC5sZW5ndGggPCAxMCB8fFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZCA9PT0gJyMgU291cmNlcyBGb3VuZCcgfHxcbiAgICAgICAgICAgICAgICAgIC9eXFxkK1xcLiQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRTb3VyY2UoaXRlbSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgIH0pLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBzdHJpbmcgaXRlbXMgaW50byBzb3VyY2Ugb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgY29uc3QgdXJsTWF0Y2ggPSBpdGVtLm1hdGNoKC8oaHR0cHM/OlxcL1xcL1teXFxzXSspLylcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHVybE1hdGNoID8gdXJsTWF0Y2hbMV0gOiBudWxsXG4gICAgICAgICAgICAgICAgICBjb25zdCB0aXRsZSA9IGl0ZW0ucmVwbGFjZSgvKGh0dHBzPzpcXC9cXC9bXlxcc10rKS8sICcnKS50cmltKCkgfHwgYFNvdXJjZSAke2luZGV4ICsgMX1gXG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUgfHwgYFNvdXJjZSAke2luZGV4ICsgMX1gLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dlYicsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBpdGVtXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBhcnNlZCkgPyBlbnN1cmVBcnJheShwYXJzZWQpIDogW2RhdGFdXG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSBhcyBzdHJ1Y3R1cmVkIHNvdXJjZSBkYXRhXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBkYXRhLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAmJiBpc1ZhbGlkU291cmNlKGxpbmUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcy5tYXAoKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB1cmxNYXRjaCA9IGxpbmUubWF0Y2goLyhodHRwcz86XFwvXFwvW15cXHNdKykvKVxuICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gdXJsTWF0Y2ggPyB1cmxNYXRjaFsxXSA6IG51bGxcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gbGluZS5yZXBsYWNlKC8oaHR0cHM/OlxcL1xcL1teXFxzXSspLywgJycpLnRyaW0oKSB8fCBgU291cmNlICR7aW5kZXggKyAxfWBcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSB8fCBgU291cmNlICR7aW5kZXggKyAxfWAsXG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd2ViJyxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGxpbmVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YSA/IFtkYXRhXSA6IFtdXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHJlc2VhcmNoRGF0YSA9IHtcbiAgICAgICAgICAgIHN1bW1hcnk6IGpzb25EYXRhWzBdIHx8ICdSZXNlYXJjaCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LicsXG4gICAgICAgICAgICBzb3VyY2VzOiBlbnN1cmVBcnJheShqc29uRGF0YVsxXSksXG4gICAgICAgICAgICBjaXRhdGlvbnM6IGVuc3VyZUFycmF5KGpzb25EYXRhWzJdKSxcbiAgICAgICAgICAgIHByb2Nlc3NMb2c6IGVuc3VyZUFycmF5KGpzb25EYXRhWzNdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaWx0ZXIgY29udGVudCB0byByZXBsYWNlICdwZXJwbGV4aXR5JyB3aXRoICdvbW5pJ1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IGZpbHRlclJlc2VhcmNoUmVzdWx0cyhyZXNlYXJjaERhdGEpXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiBmaWx0ZXJlZERhdGFcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gcGFyc2UgcmVnZXggbWF0Y2hlZCBkYXRhJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgbm8gdmFsaWQgZGF0YSB3YXMgZm91bmRcbiAgICBjb25zb2xlLmVycm9yKCdObyB2YWxpZCByZXNlYXJjaCBkYXRhIGZvdW5kIGluIHJlc3BvbnNlJylcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBcbiAgICAgIGVycm9yOiAnTm8gcmVzZWFyY2ggZGF0YSByZWNlaXZlZCBmcm9tIEFQSScsXG4gICAgICBkZWJ1ZzogcmVzdWx0LnN1YnN0cmluZygwLCA1MDApIC8vIEZpcnN0IDUwMCBjaGFycyBmb3IgZGVidWdnaW5nXG4gICAgfSlcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1Byb3h5IGVycm9yOicsIGVycm9yKVxuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IFxuICAgICAgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3I6ICcgKyBlcnJvci5tZXNzYWdlIFxuICAgIH0pXG4gIH1cbn0iXSwibmFtZXMiOlsiZmlsdGVyUmVzZWFyY2hSZXN1bHRzIiwiaGFuZGxlciIsInJlcSIsInJlcyIsIm1ldGhvZCIsInN0YXR1cyIsImpzb24iLCJlcnJvciIsInF1ZXJ5IiwiYm9keSIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZXZlbnRJZCIsImV2ZW50X2lkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicmVzdWx0c1VybCIsInJlc3VsdHNSZXNwb25zZSIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsInJlc3VsdCIsImJ1ZmZlciIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJjaHVuayIsImRlY29kZSIsImxpbmVzIiwic3BsaXQiLCJwb3AiLCJsaW5lIiwic3RhcnRzV2l0aCIsImRhdGFDb250ZW50Iiwic2xpY2UiLCJ0cmltIiwianNvbkRhdGEiLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImVuc3VyZUFycmF5IiwiaXNWYWxpZFNvdXJjZSIsInN0ciIsInRyaW1tZWQiLCJ0ZXN0IiwiZmlsdGVyIiwiaXRlbSIsIm1hcCIsImluZGV4IiwidXJsTWF0Y2giLCJtYXRjaCIsInVybCIsInRpdGxlIiwicmVwbGFjZSIsInR5cGUiLCJkZXNjcmlwdGlvbiIsInBhcnNlZCIsInJlc2VhcmNoRGF0YSIsInN1bW1hcnkiLCJzb3VyY2VzIiwiY2l0YXRpb25zIiwicHJvY2Vzc0xvZyIsImZpbHRlcmVkRGF0YSIsInN1Y2Nlc3MiLCJlIiwic3Vic3RyaW5nIiwiZGF0YU1hdGNoIiwiZGVidWciLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./pages/api/research.js\n");

/***/ }),

/***/ "(api)/./utils/contentFilter.js":
/*!********************************!*\
  !*** ./utils/contentFilter.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"filterContentRecursively\": () => (/* binding */ filterContentRecursively),\n/* harmony export */   \"filterResearchResults\": () => (/* binding */ filterResearchResults),\n/* harmony export */   \"replacePerplexityWithOmni\": () => (/* binding */ replacePerplexityWithOmni)\n/* harmony export */ });\n/**\n * Content filtering utility to replace brand mentions\n * Replaces any mention of 'perplexity' with 'omni' (case-insensitive)\n */ /**\n * Replace 'perplexity' with 'omni' in text content\n * @param {string} text - The text to filter\n * @returns {string} - The filtered text\n */ function replacePerplexityWithOmni(text) {\n    if (typeof text !== \"string\") {\n        return text;\n    }\n    // Replace all variations of 'perplexity' with 'omni'\n    return text.replace(/perplexity/gi, \"omni\").replace(/Perplexity/g, \"Omni\");\n}\n/**\n * Filter content in objects recursively\n * @param {any} obj - The object to filter\n * @returns {any} - The filtered object\n */ function filterContentRecursively(obj) {\n    if (typeof obj === \"string\") {\n        return replacePerplexityWithOmni(obj);\n    }\n    if (Array.isArray(obj)) {\n        return obj.map((item)=>filterContentRecursively(item));\n    }\n    if (obj && typeof obj === \"object\") {\n        const filtered = {};\n        for (const [key, value] of Object.entries(obj)){\n            filtered[key] = filterContentRecursively(value);\n        }\n        return filtered;\n    }\n    return obj;\n}\n/**\n * Filter research results data\n * @param {object} researchData - The research results object\n * @returns {object} - The filtered research results\n */ function filterResearchResults(researchData) {\n    if (!researchData) return researchData;\n    return filterContentRecursively(researchData);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9jb250ZW50RmlsdGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Q0FHQyxHQUVEOzs7O0NBSUMsR0FDTSxTQUFTQSx5QkFBeUIsQ0FBQ0MsSUFBSSxFQUFFO0lBQzlDLElBQUksT0FBT0EsSUFBSSxLQUFLLFFBQVEsRUFBRTtRQUM1QixPQUFPQSxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQscURBQXFEO0lBQ3JELE9BQU9BLElBQUksQ0FDUkMsT0FBTyxpQkFBaUIsTUFBTSxDQUFDLENBQy9CQSxPQUFPLGdCQUFnQixNQUFNLENBQUMsQ0FBQztBQUNwQyxDQUFDO0FBRUQ7Ozs7Q0FJQyxHQUNNLFNBQVNDLHdCQUF3QixDQUFDQyxHQUFHLEVBQUU7SUFDNUMsSUFBSSxPQUFPQSxHQUFHLEtBQUssUUFBUSxFQUFFO1FBQzNCLE9BQU9KLHlCQUF5QixDQUFDSSxHQUFHLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsSUFBSUMsS0FBSyxDQUFDQyxPQUFPLENBQUNGLEdBQUcsQ0FBQyxFQUFFO1FBQ3RCLE9BQU9BLEdBQUcsQ0FBQ0csR0FBRyxDQUFDQyxDQUFBQSxJQUFJLEdBQUlMLHdCQUF3QixDQUFDSyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRCxJQUFJSixHQUFHLElBQUksT0FBT0EsR0FBRyxLQUFLLFFBQVEsRUFBRTtRQUNsQyxNQUFNSyxRQUFRLEdBQUcsRUFBRTtRQUNuQixLQUFLLE1BQU0sQ0FBQ0MsR0FBRyxFQUFFQyxLQUFLLENBQUMsSUFBSUMsTUFBTSxDQUFDQyxPQUFPLENBQUNULEdBQUcsQ0FBQyxDQUFFO1lBQzlDSyxRQUFRLENBQUNDLEdBQUcsQ0FBQyxHQUFHUCx3QkFBd0IsQ0FBQ1EsS0FBSyxDQUFDLENBQUM7UUFDbEQsQ0FBQztRQUNELE9BQU9GLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRUQsT0FBT0wsR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVEOzs7O0NBSUMsR0FDTSxTQUFTVSxxQkFBcUIsQ0FBQ0MsWUFBWSxFQUFFO0lBQ2xELElBQUksQ0FBQ0EsWUFBWSxFQUFFLE9BQU9BLFlBQVksQ0FBQztJQUV2QyxPQUFPWix3QkFBd0IsQ0FBQ1ksWUFBWSxDQUFDLENBQUM7QUFDaEQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL29tbmktYWktaW50ZXJmYWNlLy4vdXRpbHMvY29udGVudEZpbHRlci5qcz9hNDA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udGVudCBmaWx0ZXJpbmcgdXRpbGl0eSB0byByZXBsYWNlIGJyYW5kIG1lbnRpb25zXG4gKiBSZXBsYWNlcyBhbnkgbWVudGlvbiBvZiAncGVycGxleGl0eScgd2l0aCAnb21uaScgKGNhc2UtaW5zZW5zaXRpdmUpXG4gKi9cblxuLyoqXG4gKiBSZXBsYWNlICdwZXJwbGV4aXR5JyB3aXRoICdvbW5pJyBpbiB0ZXh0IGNvbnRlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gZmlsdGVyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBmaWx0ZXJlZCB0ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlUGVycGxleGl0eVdpdGhPbW5pKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIFxuICAvLyBSZXBsYWNlIGFsbCB2YXJpYXRpb25zIG9mICdwZXJwbGV4aXR5JyB3aXRoICdvbW5pJ1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9wZXJwbGV4aXR5L2dpLCAnb21uaScpXG4gICAgLnJlcGxhY2UoL1BlcnBsZXhpdHkvZywgJ09tbmknKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgY29udGVudCBpbiBvYmplY3RzIHJlY3Vyc2l2ZWx5XG4gKiBAcGFyYW0ge2FueX0gb2JqIC0gVGhlIG9iamVjdCB0byBmaWx0ZXJcbiAqIEByZXR1cm5zIHthbnl9IC0gVGhlIGZpbHRlcmVkIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyQ29udGVudFJlY3Vyc2l2ZWx5KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmVwbGFjZVBlcnBsZXhpdHlXaXRoT21uaShvYmopO1xuICB9XG4gIFxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoaXRlbSA9PiBmaWx0ZXJDb250ZW50UmVjdXJzaXZlbHkoaXRlbSkpO1xuICB9XG4gIFxuICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgICBmaWx0ZXJlZFtrZXldID0gZmlsdGVyQ29udGVudFJlY3Vyc2l2ZWx5KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xuICB9XG4gIFxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEZpbHRlciByZXNlYXJjaCByZXN1bHRzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNlYXJjaERhdGEgLSBUaGUgcmVzZWFyY2ggcmVzdWx0cyBvYmplY3RcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gVGhlIGZpbHRlcmVkIHJlc2VhcmNoIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclJlc2VhcmNoUmVzdWx0cyhyZXNlYXJjaERhdGEpIHtcbiAgaWYgKCFyZXNlYXJjaERhdGEpIHJldHVybiByZXNlYXJjaERhdGE7XG4gIFxuICByZXR1cm4gZmlsdGVyQ29udGVudFJlY3Vyc2l2ZWx5KHJlc2VhcmNoRGF0YSk7XG59Il0sIm5hbWVzIjpbInJlcGxhY2VQZXJwbGV4aXR5V2l0aE9tbmkiLCJ0ZXh0IiwicmVwbGFjZSIsImZpbHRlckNvbnRlbnRSZWN1cnNpdmVseSIsIm9iaiIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIml0ZW0iLCJmaWx0ZXJlZCIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImZpbHRlclJlc2VhcmNoUmVzdWx0cyIsInJlc2VhcmNoRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./utils/contentFilter.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(api)/./pages/api/research.js"));
module.exports = __webpack_exports__;

})();